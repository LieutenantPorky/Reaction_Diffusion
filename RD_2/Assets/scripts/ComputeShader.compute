// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Reaction_Diffusion

#define groupNum 5
#define groupSize 10
#define dt 0.6

// reaction values

#define diffU 0.25
#define diffV 0.05

#define f 0.1
#define sK 0.063


// Create Struct to hold data

struct meshData {
  float3 pos;
  float4 color;
};

struct voxelState {
  float u;
  float v;
};

RWStructuredBuffer<meshData> positions;
RWStructuredBuffer<voxelState> states;
float globalTime;

// Transform from a vec3 index to scalar index (to access proper position in the buffer)

int getAbsoluteIndex(int3 id, int totalSize) {
  return id.x + id.y * totalSize + id.z * totalSize * totalSize;
}

// 1 and 3 dimensional noise algorithms

float random (float x) {
    return frac(sin(x)*43758.5453123);
}

float random (float3 st) {
    return frac(sin(dot(st, float3(12.9898,78.233,42.453)))*43758.5453123);
}




[numthreads(groupSize, groupSize, groupSize)]

void Reaction_Diffusion (uint3 id : SV_DispatchThreadID)
{
  // Obtain the scalar index to access the buffer
  int totalSize = groupNum * groupSize;
  int index = getAbsoluteIndex(id, totalSize);

  // Define the laplacian convolution tensor
  float laplacianKernel[3][3][3] = {
    {{0.125,0.25,0.125},
     {0.25, 0.5, 0.25 },
     {0.125,0.25,0.125}},

    {{0.25 ,0.5,0.25 },
     {0.50 ,-7.0,0.5 },
     {0.25 ,0.5,0.25 }},

   {{0.125,0.25,0.125},
    {0.25, 0.5, 0.25 },
    {0.125,0.25,0.125}}
  };

  // Calculate laplacian
  float2 laplacian = float2(0.0,0.0);

  for (int i = 0; i<3; i++) {
    for (int j = 0; j<3; j++) {
      for (int k = 0; k<3; k++) {
        int arrayID = clamp(getAbsoluteIndex(id + uint3(i,j,k) - uint3(1,1,1), totalSize),0, totalSize * totalSize * totalSize - 1);
        float2 posValue = float2(states[arrayID].u, states[arrayID].v);
        laplacian += posValue * laplacianKernel[i][j][k];
      }
    }
  }

  // Calculate differentials based on Gray-Scott model
  float u = states[index].u;
  float v = states[index].v;

  // Add smooth noise to the reaction constants
  float rT = random(globalTime);
  float noise = smoothstep(.999+rT*0.0001,1.,1.)*random((float3)id)*rT;

  float F  = f + noise * 0.025 - 0.0005;
  float K  = sK + noise * 0.025 - 0.0005;



  float du = diffU * laplacian.r - u*v*v + F * (1.0 - u);
  float dv = diffV * laplacian.g + u*v*v - (F + K) * v;


  // update concentrations

  states[index].u += du * dt;
  states[index].v += dv * dt;

  // Write to output buffer for the actual shader

  positions[index].pos = 0.2 * float3((float)id.x, (float)id.y, (float)id.z) - float3(5.0,5.0,5.0);
  positions[index].color = float4(clamp(float2(u,v),0.0,1.0), 0.0, 1.0);
}
