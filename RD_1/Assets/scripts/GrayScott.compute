// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel RD

#define groupSize 3
#define groupNum 1

// Create a struct to store concentrations of u and v

struct Concentrations {
  float u;
  float v;
  float w;
};

// Map uint3 index to a scalar index for the buffer
int getPos (uint3 threadID) {
  return threadID.x + threadID.y * groupSize * groupNum + threadID.z * groupSize * groupSize * groupNum * groupNum;
};

RWStructuredBuffer<Concentrations> dataBuffer;

[numthreads(groupSize,groupSize,groupSize)]

void RD (uint3 id : SV_DispatchThreadID)
{

  float laplacianKernel[3][3][3] = {
    {{0.125,0.25,0.125},
     {0.25, 0.5, 0.25 },
     {0.125,0.25,0.125}},

    {{0.25 ,0.5,0.25 },
     {0.50 ,-7.0,0.5 },
     {0.25 ,0.5,0.25 }},

   {{0.125,0.25,0.125},
    {0.25, 0.5, 0.25 },
    {0.125,0.25,0.125}}
  }; // 3x3x3 tensor for the discrete laplacian convolution

  dataBuffer[getPos(id)].u = id.x;
  dataBuffer[getPos(id)].v = id.y;
  dataBuffer[getPos(id)].w = id.z;

  dataBuffer[getPos(id)].u = laplacianKernel[id.x][id.y][id.z];
}
